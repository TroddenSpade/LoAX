/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

'use strict';var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};function _objectWithoutProperties(obj, keys) {var target = {};for (var i in obj) {if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];}return target;}function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}

const DependencyGraph = require('./node-haste/DependencyGraph');
const Transformer = require('./JSTransformer');

const assert = require('assert');
const fs = require('fs');
const getTransformCacheKeyFn = require('./lib/getTransformCacheKeyFn');
const toLocalPath = require('./node-haste/lib/toLocalPath');var _require =

require('metro-cache');const Cache = _require.Cache,stableHash = _require.stableHash;const





hasOwnProperty = Object.prototype.hasOwnProperty;

class Bundler {






  constructor(opts) {
    opts.watchFolders.forEach(verifyRootExists);

    this._opts = opts;
    this._cache = new Cache(opts.cacheStores);

    this._transformer = new Transformer({
      maxWorkers: opts.maxWorkers,
      reporters: {
        stdoutChunk: chunk =>
        opts.reporter.update({ type: 'worker_stdout_chunk', chunk }),
        stderrChunk: chunk =>
        opts.reporter.update({ type: 'worker_stderr_chunk', chunk }) },

      workerPath: opts.transformer.workerPath || undefined });


    this._depGraphPromise = DependencyGraph.load({
      assetExts: opts.resolver.assetExts,
      blacklistRE: opts.resolver.blacklistRE,
      extraNodeModules: opts.resolver.extraNodeModules,
      hasteImplModulePath: opts.resolver.hasteImplModulePath,
      mainFields: opts.resolver.resolverMainFields,
      maxWorkers: opts.maxWorkers,
      platforms: new Set(opts.resolver.platforms),
      projectRoot: opts.projectRoot,
      providesModuleNodeModules: opts.resolver.providesModuleNodeModules,
      reporter: opts.reporter,
      resetCache: opts.resetCache,
      resolveRequest: opts.resolver.resolveRequest,
      sourceExts: opts.resolver.sourceExts,
      useWatchman: opts.resolver.useWatchman,
      watch: opts.watch,
      watchFolders: opts.watchFolders });


    try {
      const getTransformCacheKey = getTransformCacheKeyFn({
        babelTransformerPath: opts.transformer.babelTransformerPath,
        cacheVersion: opts.cacheVersion,
        projectRoot: opts.projectRoot,
        transformerPath: opts.transformerPath });


      this._baseHash = stableHash([getTransformCacheKey()]).toString('binary');
    } catch (e) {
      this.end();
      throw e;
    }
  }

  getOptions() {
    return this._opts;
  }

  end() {var _this = this;return _asyncToGenerator(function* () {
      _this._transformer.kill();
      yield _this._depGraphPromise.then(function (dependencyGraph) {return (
          dependencyGraph.getWatcher().end());});})();

  }

  getDependencyGraph() {
    return this._depGraphPromise;
  }

  transformFile(
  filePath,
  workerOptions)
  {var _this2 = this;return _asyncToGenerator(function* () {
      const cache = _this2._cache;const


      assetPlugins =




















      workerOptions.assetPlugins,assetRegistryPath = workerOptions.assetRegistryPath,asyncRequireModulePath = workerOptions.asyncRequireModulePath,_babelTransformerPath = workerOptions.babelTransformerPath,dynamicDepsInPackages = workerOptions.dynamicDepsInPackages,minifierPath = workerOptions.minifierPath,optimizationSizeLimit = workerOptions.optimizationSizeLimit;var _workerOptions$transf = workerOptions.transformOptions;const customTransformOptions = _workerOptions$transf.customTransformOptions,enableBabelRCLookup = _workerOptions$transf.enableBabelRCLookup,experimentalImportSupport = _workerOptions$transf.experimentalImportSupport,dev = _workerOptions$transf.dev,hot = _workerOptions$transf.hot,inlineRequires = _workerOptions$transf.inlineRequires,minify = _workerOptions$transf.minify,platform = _workerOptions$transf.platform,_projectRoot = _workerOptions$transf.projectRoot,type = workerOptions.type,extra = _objectWithoutProperties(workerOptions, ['assetPlugins', 'assetRegistryPath', 'asyncRequireModulePath', 'babelTransformerPath', 'dynamicDepsInPackages', 'minifierPath', 'optimizationSizeLimit', 'transformOptions', 'type']);

      for (const key in extra) {
        if (hasOwnProperty.call(extra, key)) {
          throw new Error(
          'Extra keys detected: ' + Object.keys(extra).join(', '));

        }
      }

      const localPath = toLocalPath(_this2._opts.watchFolders, filePath);

      const partialKey = stableHash([
      // This is the hash related to the global Bundler config.
      _this2._baseHash,

      // Path.
      localPath,

      // We cannot include "transformCodeOptions" because of "projectRoot".
      assetPlugins,
      assetRegistryPath,
      asyncRequireModulePath,
      dynamicDepsInPackages,
      minifierPath,
      optimizationSizeLimit,

      customTransformOptions,
      enableBabelRCLookup,
      experimentalImportSupport,
      dev,
      hot,
      inlineRequires,
      minify,
      platform,
      type]);


      const sha1 = (yield _this2.getDependencyGraph()).getSha1(filePath);
      let fullKey = Buffer.concat([partialKey, Buffer.from(sha1, 'hex')]);
      const result = yield cache.get(fullKey);

      // A valid result from the cache is used directly; otherwise we call into
      // the transformer to computed the corresponding result.
      const data = result ?
      { result, sha1 } :
      yield _this2._transformer.transform(
      filePath,
      localPath,
      _this2._opts.transformerPath,
      workerOptions);


      // Only re-compute the full key if the SHA-1 changed. This is because
      // references are used by the cache implementation in a weak map to keep
      // track of the cache that returned the result.
      if (sha1 !== data.sha1) {
        fullKey = Buffer.concat([partialKey, Buffer.from(data.sha1, 'hex')]);
      }

      cache.set(fullKey, data.result);

      return _extends({},
      data.result, {
        getSource() {
          return fs.readFileSync(filePath);
        } });})();

  }}


function verifyRootExists(root) {
  // Verify that the root exists.
  assert(fs.statSync(root).isDirectory(), 'Root has to be a valid directory');
}

module.exports = Bundler;