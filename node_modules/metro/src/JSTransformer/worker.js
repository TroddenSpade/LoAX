/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

'use strict';var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};let transform = (() => {var _ref = _asyncToGenerator(

















































































































  function* (
  filename,
  localPath,
  data,
  options)
  {
    const sourceCode = data.toString('utf8');
    let type = 'js/module';

    if (options.type === 'asset') {
      type = 'js/module/asset';
    }
    if (options.type === 'script') {
      type = 'js/script';
    }

    if (filename.endsWith('.json')) {
      let code = JsFileWrapping.wrapJson(sourceCode);
      let map = [];

      if (options.transformOptions.minify) {var _ref2 =
        yield minifyCode(
        filename,
        code,
        sourceCode,
        map,
        options.minifierPath);map = _ref2.map;code = _ref2.code;

      }

      return { dependencies: [], output: [{ data: { code, map }, type }] };
    }

    // $FlowFixMe TODO t26372934 Plugin system
    const transformer = require(options.babelTransformerPath);

    const transformerArgs = {
      filename,
      localPath,
      options: _extends({},
      options.transformOptions, {
        // Inline requires are now performed at a secondary step. We cannot
        // unfortunately remove it from the internal transformer, since this one
        // is used by other tooling, and this would affect it.
        inlineRequires: false }),

      plugins: [],
      src: sourceCode };


    const transformResult =
    type === 'js/module/asset' ?
    yield assetTransformer.transform(
    transformerArgs,
    options.assetRegistryPath,
    options.assetPlugins) :

    yield transformer.transform(transformerArgs);

    // Transformers can ouptut null ASTs (if they ignore the file). In that case
    // we need to parse the module source code to get their AST.
    let ast =
    transformResult.ast || babylon.parse(sourceCode, { sourceType: 'module' });var _generateImportNames =

    generateImportNames(ast);const importDefault = _generateImportNames.importDefault,importAll = _generateImportNames.importAll;

    // Add "use strict" if the file was parsed as a module, and the directive did
    // not exist yet.
    const directives = ast.program.directives;

    if (
    ast.program.sourceType === 'module' &&
    directives.findIndex(function (d) {return d.value.value === 'use strict';}) === -1)
    {
      directives.push(types.directive(types.directiveLiteral('use strict')));
    }

    // Perform the import-export transform (in case it's still needed), then
    // fold requires and perform constant folding (if in dev).
    const plugins = [];
    const opts = _extends({},
    options.transformOptions, {
      inlineableCalls: [importDefault, importAll],
      importDefault,
      importAll });


    if (options.transformOptions.experimentalImportSupport) {
      plugins.push([importExportPlugin, opts]);
    }

    if (options.transformOptions.inlineRequires) {
      plugins.push([inlineRequiresPlugin, opts]);
    }

    if (!options.transformOptions.dev) {
      plugins.push([constantFoldingPlugin, opts]);
      plugins.push([inlinePlugin, opts]);
    }var _transformFromAstSync =

    transformFromAstSync(ast, '', {
      ast: true,
      babelrc: false,
      code: false,
      configFile: false,
      comments: false,
      compact: false,
      filename: localPath,
      plugins,
      sourceMaps: false });ast = _transformFromAstSync.ast;


    let dependencyMapName = '';
    let dependencies;
    let wrappedAst;

    // If the module to transform is a script (meaning that is not part of the
    // dependency graph and it code will just be prepended to the bundle modules),
    // we need to wrap it differently than a commonJS module (also, scripts do
    // not have dependencies).
    if (type === 'js/script') {
      dependencies = [];
      wrappedAst = JsFileWrapping.wrapPolyfill(ast);
    } else {
      try {
        const opts = {
          asyncRequireModulePath: options.asyncRequireModulePath,
          dynamicRequires: getDynamicDepsBehavior(
          options.dynamicDepsInPackages,
          filename),

          inlineableCalls: [importDefault, importAll],
          keepRequireNames: options.transformOptions.dev };var _collectDependencies =

        collectDependencies(ast, opts);dependencies = _collectDependencies.dependencies;dependencyMapName = _collectDependencies.dependencyMapName;
      } catch (error) {
        if (error instanceof collectDependencies.InvalidRequireCallError) {
          throw new InvalidRequireCallError(error, filename);
        }
        throw error;
      }var _JsFileWrapping$wrapM =

      JsFileWrapping.wrapModule(
      ast,
      importDefault,
      importAll,
      dependencyMapName);wrappedAst = _JsFileWrapping$wrapM.ast;

    }

    const reserved =
    options.transformOptions.minify &&
    data.length <= options.optimizationSizeLimit ?
    normalizePseudoglobals(wrappedAst) :
    [];

    const result = generate(
    wrappedAst,
    {
      comments: false,
      compact: false,
      filename: localPath,
      retainLines: false,
      sourceFileName: filename,
      sourceMaps: true },

    sourceCode);


    let map = result.rawMappings ? result.rawMappings.map(toSegmentTuple) : [];
    let code = result.code;

    if (options.transformOptions.minify) {var _ref3 =
      yield minifyCode(
      filename,
      result.code,
      sourceCode,
      map,
      options.minifierPath,
      { reserved });map = _ref3.map;code = _ref3.code;

    }

    return { dependencies, output: [{ data: { code, map }, type }] };
  });return function transform(_x, _x2, _x3, _x4) {return _ref.apply(this, arguments);};})();let minifyCode = (() => {var _ref4 = _asyncToGenerator(

  function* (
  filename,
  code,
  source,
  map,
  minifierPath)




  {let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
    const sourceMap = fromRawMappings([
    { code, source, map, path: filename }]).
    toMap(undefined, {});

    const minify = getMinifier(minifierPath);

    try {
      const minified = minify.withSourceMap(code, sourceMap, filename, options);

      return {
        code: minified.code,
        map: minified.map ?
        toBabelSegments(minified.map).map(toSegmentTuple) :
        [] };

    } catch (error) {
      if (error.constructor.name === 'JS_Parse_Error') {
        throw new Error(
        `${error.message} in file ${filename} at ${error.line}:${error.col}`);

      }

      throw error;
    }
  });return function minifyCode(_x5, _x6, _x7, _x8, _x9) {return _ref4.apply(this, arguments);};})();function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}const JsFileWrapping = require('../ModuleGraph/worker/JsFileWrapping');const assetTransformer = require('../assetTransformer');const babylon = require('@babel/parser');const collectDependencies = require('../ModuleGraph/worker/collectDependencies');const constantFoldingPlugin = require('./worker/constant-folding-plugin');const generateImportNames = require('../ModuleGraph/worker/generateImportNames');const generate = require('@babel/generator').default;const getMinifier = require('../lib/getMinifier');const importExportPlugin = require('./worker/import-export-plugin');const inlinePlugin = require('./worker/inline-plugin');const inlineRequiresPlugin = require('babel-preset-fbjs/plugins/inline-requires');const normalizePseudoglobals = require('./worker/normalizePseudoglobals');var _require = require('@babel/core');const transformFromAstSync = _require.transformFromAstSync;const types = require('@babel/types');var _require2 = require('metro-source-map');const fromRawMappings = _require2.fromRawMappings,toBabelSegments = _require2.toBabelSegments,toSegmentTuple = _require2.toSegmentTuple;function getDynamicDepsBehavior(inPackages, filename) {switch (inPackages) {case 'reject':return 'reject';case 'throwAtRuntime':const isPackage = /(?:^|[/\\])node_modules[/\\]/.test(filename);return isPackage ? inPackages : 'reject';default:inPackages;throw new Error(`invalid value for dynamic deps behavior: \`${inPackages}\``);}}

function getTransformDependencies() {
  return [
  require.resolve('../ModuleGraph/worker/JsFileWrapping'),
  require.resolve('../assetTransformer'),
  require.resolve('../ModuleGraph/worker/collectDependencies'),
  require.resolve('./worker/constant-folding-plugin'),
  require.resolve('../lib/getMinifier'),
  require.resolve('./worker/inline-plugin'),
  require.resolve('./worker/normalizePseudoglobals'),
  require.resolve('../ModuleGraph/worker/optimizeDependencies')];

}

class InvalidRequireCallError extends Error {



  constructor(
  innerError,
  filename)
  {
    super(`${filename}:${innerError.message}`);
    this.innerError = innerError;
    this.filename = filename;
  }}


module.exports = {
  transform,
  getTransformDependencies };